@interface %«className»Operation ()
- (void)completedWithError:(NSError *)error;

@property(nonatomic, strong) %«className»Response *response;
@property(nonatomic, strong) %«className»SuccessBlock success;
@property(nonatomic, strong) %«className»ErrorBlock error;
@property(nonatomic) BOOL isFinished;
@end

@implementation %«className»

+ (NSTimeInterval)defaultTimeout {
    return 10;
}

- (id)init {
    if ((self = [super init])) {
        _customHeaders = [NSMutableDictionary new];
        _timeout = [[self class] defaultTimeout];
    }

    return self;
}

- (id)initWithAddress:(NSString *)anAddress {
    if ((self = [self init]))
        self.address = [NSURL URLWithString:anAddress];

    return self;
}

- (NSString *)MIMEType {
%IFEQ soapVersion 1.2
    return @"application/soap+xml";
%ELSE
    return @"text/xml";
%ENDIF
}

- (void)addCookie:(NSHTTPCookie *)toAdd {
    if (toAdd) {
        if (!self.cookies) self.cookies = [NSMutableArray new];
        [self.cookies addObject:toAdd];
    }
}

%FOREACH operation in operations
- (%«className»_%«operation.className»*)%«operation.invokeString» success:(%«className»SuccessBlock)success error:(%«className»ErrorBlock)error {
    %«className»_%«operation.className» *op = [[%«className»_%«operation.className» alloc] initWithBinding:self success:success error:error
%FOREACH part in operation.input.bodyParts
        %«part.name»:a%«part.uname»
%ENDFOR
    ];
    [op start];
    return op;
}
%ENDFOR

- (NSURLRequest *)URLRequestForBody:(NSString *)outputBody soapAction:(NSString *)soapAction forOperation:(%«className»Operation *)operation {
    if (!outputBody) {
        NSError *err = [NSError errorWithDomain:@"%«className»NULLRequestException" code:0 userInfo:nil];
        [operation completedWithError:err];
        return nil;
    }

    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:self.address 
                                                           cachePolicy:NSURLRequestReloadIgnoringLocalAndRemoteCacheData
                                                       timeoutInterval:self.timeout];
    NSData *bodyData = [outputBody dataUsingEncoding:NSUTF8StringEncoding];

    if (self.cookies) {
        [request setAllHTTPHeaderFields:[NSHTTPCookie requestHeaderFieldsWithCookies:self.cookies]];
    }

    [request setValue:soapAction forHTTPHeaderField:@"SOAPAction"];
    [request setValue:[[self MIMEType] stringByAppendingString:@"; charset=utf-8"] forHTTPHeaderField:@"Content-Type"];
    [request setValue:[NSString stringWithFormat:@"%lu", (unsigned long)[bodyData length]] forHTTPHeaderField:@"Content-Length"];
    [request setValue:self.address.host forHTTPHeaderField:@"Host"];

    for (NSString *eachHeaderField in self.customHeaders) {
        [request setValue:[self.customHeaders objectForKey:eachHeaderField] forHTTPHeaderField:eachHeaderField];
    }

    [request setHTTPMethod:@"POST"];
    // set version 1.1 - how?
    [request setHTTPBody:bodyData];

    if (self.logXMLInOut) {
        NSLog(@"OutputHeaders:\n%@", [request allHTTPHeaderFields]);
        NSLog(@"OutputBody:\n%@", outputBody);
    }

    return request;
}

@end

@implementation %«className»Operation
- (id)initWithBinding:(%«className» *)aBinding success:(%«className»SuccessBlock)success error:(%«className»ErrorBlock)error {
    if ((self = [super init])) {
        self.binding = aBinding;
        self.success = success;
        self.error = error;
    }

    return self;
}

- (void)cancel {
    [self.URLSessionTask cancel];
    [super cancel];
}

- (void)completedWithResponse:(%«className»Response *)aResponse {
    NSError *error;

    if (self.binding.errorCreationBlock) {
        error = self.binding.errorCreationBlock(aResponse);
    }

    if (!error) {
        error = aResponse.error;
    }

    if (error) {
        if (self.error)
            self.error(error);
    }
    else if (self.success)
        self.success(aResponse.headers, aResponse.bodyParts);
    self.success = nil;
    self.error = nil;
    self.isFinished = YES;
}

- (void)completedWithError:(NSError *)error {
    if (self.binding.logXMLInOut && (![[error domain] isEqualToString:(__bridge NSString *)kCFErrorDomainCFNetwork] || [error code] != kCFURLErrorCancelled)) {
        NSLog(@"ResponseError:\n%@", error);
    }
    self.response.error = error;
    [self completedWithResponse:self.response];
}

- (void)processResponseNode:(xmlNodePtr)node classes:(NSDictionary *)classes result:(NSMutableArray *)result {
    if (node->type != XML_ELEMENT_NODE) return;
    NSString *name = [NSString stringWithXmlString:(xmlChar *)node->name free:NO];
    id object = [classes[name] deserializeNode:node];
    if (object)
        [result addObject:object];
}

- (void)handleData:(NSData *)data response:(NSURLResponse *)response error:(NSError *)error request:(NSURLRequest *)request {
    if (self.binding.operationCompletionBlock) {
        self.binding.operationCompletionBlock(NSStringFromClass([self class]), request, data, response, error);
    }

    if (error) {
        [self completedWithError:error];
    }

    if (![response isKindOfClass:[NSHTTPURLResponse class]]) {
        NSLog(@"Unexpected url response: %@", response);
        return;
    }

    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;

    if (self.binding.logXMLInOut) {
        NSLog(@"ResponseStatus: %ld\n", (long)[httpResponse statusCode]);
        NSLog(@"ResponseHeaders:\n%@", [httpResponse allHeaderFields]);
    }

    self.binding.cookies = [[NSHTTPCookie cookiesWithResponseHeaderFields:[httpResponse allHeaderFields] forURL:self.binding.address] mutableCopy];

    if ([response.MIMEType rangeOfString:[self.binding MIMEType]].length != 0) {
        [self didFinishLoadingWithData:data];
    } else {
        NSInteger contentLength = [httpResponse.allHeaderFields[@"Content-Length"] integerValue];

        if (contentLength == 0 && self.binding.ignoreEmptyResponse) {
            [self completedWithResponse:self.response];
            return;
        }

        if ([httpResponse statusCode] >= 400) {
            NSDictionary *userInfo =  @{NSURLErrorKey: httpResponse.URL ?: @"",
                                        NSLocalizedDescriptionKey: [NSHTTPURLResponse localizedStringForStatusCode:[httpResponse statusCode]]};
            error = [NSError errorWithDomain:[NSString stringWithFormat:@"%@ResponseHTTP", NSStringFromClass([self class])] code:[httpResponse statusCode] userInfo:userInfo];
        } else {
            NSDictionary *userInfo =  @{NSURLErrorKey: httpResponse.URL ?: @"",
                                        NSLocalizedDescriptionKey: [NSString stringWithFormat:@"Unexpected response MIME type to SOAP call:%@", response.MIMEType]};
            error = [NSError errorWithDomain:[NSString stringWithFormat:@"%@ResponseHTTP", NSStringFromClass([self class])] code:1 userInfo:userInfo];
        }

        [self completedWithError:error];
    }
}

- (void)didFinishLoadingWithData:(NSData *)data {
    // Implemented by subclasses
}

@end

%FOREACH operation in operations
@implementation %«className»_%«operation.className»

- (id)initWithBinding:(%«className» *)aBinding success:(%«className»SuccessBlock)success error:(%«className»ErrorBlock)error
%FOREACH part in operation.input.bodyParts
%«part.name»:(%«part.type.variableTypeName»)a%«part.uname»
%ENDFOR
{
    if ((self = [super initWithBinding:aBinding success:success error:error])) {
%FOREACH part in operation.input.bodyParts
        self.%«part.name» = a%«part.uname»;
%ENDFOR
    }

    return self;
}

- (void)main {
    self.response = [%«className»Response new];

    NSString *operationXMLString = [%«className»_envelope serializedFormUsingDelegate:self];
    operationXMLString = self.binding.soapSigner ? [self.binding.soapSigner signRequest:operationXMLString] : operationXMLString;

    NSURLRequest *request = [self.binding URLRequestForBody:operationXMLString soapAction:@"%«operation.soapAction»" forOperation:self];
    NSURLSessionDataTask *dataTask = [self.binding.URLSession dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
        [self handleData:data response:response error:error request:request];
    }];

    self.URLSessionTask = dataTask;
    
    [dataTask resume];
}

- (void)addSoapBody:(xmlNodePtr)root {
%IFDEF operation.input.headers
    xmlNodePtr headerNode = xmlNewDocNode(root->doc, NULL, (const xmlChar *)"Header", NULL);

%FOREACH header in operation.input.headers
    if (self.binding.%«header.name»Header)
        [%«header.type.className» serializeToChildOf:headerNode withName:"%«header.type.prefix»:%«header.name»" value:self.binding.%«header.name»Header];

%ENDFOR
    if (xmlChildElementCount(headerNode) > 0) {
        xmlAddChild(root, headerNode);
        xmlSetNs(headerNode, root->ns);
    }
%ENDIF
%IFDEF operation.input.bodyParts
    xmlNodePtr bodyNode = xmlNewDocNode(root->doc, NULL, (const xmlChar *)"Body", NULL);
    xmlAddChild(root, bodyNode);

%FOREACH part in operation.input.bodyParts
%IF part.isArray
    for (%«part.type.variableTypeName» item in _%«part.name»)
        [%«part.type.className» serializeToChildOf:bodyNode withName:"%«part.type.prefix»:%«part.wsdlName»" value:item];

%ELSE
    if (_%«part.name»)
        [%«part.type.className» serializeToChildOf:bodyNode withName:"%«part.type.prefix»:%«part.wsdlName»" value:_%«part.name»];

%ENDIF
%ENDFOR
    xmlSetNs(bodyNode, root->ns);
%ENDIF
}

- (void)didFinishLoadingWithData:(NSData *)data {
    if (self.binding.logXMLInOut) {
        NSLog(@"ResponseBody:\n%@", [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);
    }

    xmlDocPtr doc = xmlReadMemory([data bytes], (int)[data length], NULL, NULL, XML_PARSE_COMPACT | XML_PARSE_NOBLANKS);
    if (doc == NULL) {
        NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"Errors while parsing returned XML"};
        self.response.error = [NSError errorWithDomain:@"%«className»ResponseXML" code:1 userInfo:userInfo];
        goto done;
    }

    for (xmlNodePtr cur = xmlDocGetRootElement(doc)->children; cur; cur = cur->next) {
        if (cur->type != XML_ELEMENT_NODE) continue;
%IF operation.output.hasHeaders

        if (xmlStrEqual(cur->name, (const xmlChar *) "Header")) {
            NSMutableArray *responseHeaders = [NSMutableArray array];
            NSDictionary *headers = @{
%FOREACH header in operation.output.headers
                @"%«header.wsdlName»": [%«header.type.className» class],
%ENDFOR
            };

            for (xmlNodePtr headerNode = cur->children; headerNode; headerNode = headerNode->next)
                [self processResponseNode:headerNode classes:headers result:responseHeaders];

            self.response.headers = responseHeaders;
            continue;
        }
%ENDIF

        if (xmlStrEqual(cur->name, (const xmlChar *) "Body")) {
            NSMutableArray *responseBodyParts = [NSMutableArray array];
            NSDictionary *bodyParts = @{
%FOREACH part in operation.output.bodyParts
                @"%«part.wsdlName»": [%«part.type.className» class],
%ENDFOR
            };
            for (xmlNodePtr bodyNode = cur->children; bodyNode; bodyNode = bodyNode->next) {
                [self processResponseNode:bodyNode classes:bodyParts result:responseBodyParts];

                if (cur->type != XML_ELEMENT_NODE) continue;
                if ((bodyNode->ns && xmlStrEqual(bodyNode->ns->prefix, cur->ns->prefix)) &&
                    xmlStrEqual(bodyNode->name, (const xmlChar *)"Fault")) {
                    USSOAPFault *bodyObject = [USSOAPFault deserializeNode:bodyNode expectedExceptions:@{}];
                    if (bodyObject) [responseBodyParts addObject:bodyObject];
                }
            }

            self.response.bodyParts = responseBodyParts;
        }
    }

    xmlFreeDoc(doc);

done:
    [self completedWithResponse:self.response];
}

@end
%ENDFOR

@implementation %«className»_envelope
+ (NSString *)serializedFormUsingDelegate:(id)delegate {
    xmlDocPtr doc = xmlNewDoc((const xmlChar *)XML_DEFAULT_VERSION);

    if (doc == NULL) {
        NSLog(@"Error creating the xml document tree");
        return @"";
    }

    xmlNodePtr root = xmlNewDocNode(doc, NULL, (const xmlChar *)"Envelope", NULL);
    xmlDocSetRootElement(doc, root);

%IFEQ soapVersion 1.2
    xmlNsPtr soapEnvelopeNs = xmlNewNs(root, (const xmlChar *)"http://www.w3.org/2003/05/soap-envelope", (const xmlChar *)"soap");
%ELSE
    xmlNsPtr soapEnvelopeNs = xmlNewNs(root, (const xmlChar *)"http://schemas.xmlsoap.org/soap/envelope/", (const xmlChar *)"soap");
%ENDIF

    xmlSetNs(root, soapEnvelopeNs);

    xmlNsPtr xslNs = xmlNewNs(root, (const xmlChar *)"http://www.w3.org/1999/XSL/Transform", (const xmlChar *)"xsl");
    xmlNewNsProp(root, xslNs, (const xmlChar *)"version", (const xmlChar *)"1.0");
%FOREACH schema in wsdl.schemas
    xmlNewNs(root, (const xmlChar *)"%«schema.fullName»", (const xmlChar *)"%«schema.prefix»");
%ENDFOR

    [delegate addSoapBody:root];

    xmlChar *buf;
    int size;
    xmlDocDumpFormatMemory(doc, &buf, &size, 1);

    NSString *serializedForm = [NSString stringWithXmlString:buf free:YES];

    xmlFreeDoc(doc);
    return serializedForm;
}

@end

@implementation %«className»Response
@end
